???+ 视频题解
[暂无]()

---

## 第 1 题 数列分段

题目链接: [数列分段](http://118.190.20.162/view.page?gpid=T32)

TAG: `基础语法`

思路:

`遍历整个数组，若相邻两个数不同则答案数加1`

代码:

```cpp linenums="1"
#include<bits/stdc++.h>
using namespace std;

int main(){
    int n;
    cin>>n;
    vector<int> a(n); // vector为可变长数组，使用普通数组也可以
    for(int i=0;i<n;i++){
        cin>>a[i];
    }
    int ans=1; // 初始长度为1
    for(int i=1;i<n;i++){ // 遍历数组
        if(a[i]!=a[i-1]){ // 遇到需要分段的情况
            ans++; // 数列段长度加1
        }
    }
    cout<<ans;
    return 0;
}
```

---

## 第 2 题 日期计算

题目链接: [日期计算](http://118.190.20.162/view.page?gpid=T31)

TAG: `基础语法` `模拟`

思路:

`记录到每个月结束位置过去了多少天，然后找到最后一个小于题目给定天数的月份再加一个月就是答案的月份，答案的天数就是总天数-到找到的月份结束为止过去的天数`

代码:

```cpp linenums="1"
#include<bits/stdc++.h>
using namespace std;

// 判断是否为闰年
bool is_leap_year(int y){
    return y%400==0||(y%4==0&&y%100!=0);
}

int main(){
    int y,d;
    cin>>y>>d;
    // 记录各月的天数
    int m[]={0,31,28,31,30,31,30,31,31,30,31,30,31};
    // 如果是闰年，二月天数加1
    if(is_leap_year(y)){
        m[2]++;
    }
    // s[i]表示到第i个月结束为止，一共过了多少天
    int s[15]={0};
    for(int i=1;i<=12;i++){
        s[i]=s[i-1]+m[i];
    }
    // id记录答案的月份
    int id=1;
    for(int i=1;i<=12;i++){
        if(d<=s[i]){ // 找到答案的月份
            id=i;
            break;
        }
    }
    // 天数为实际过去的天数-已经经过的天数
    cout<<id<<"\n"<<d-s[id-1];
    return 0;
}
```

---

## 第 3 题 模板生成系统

题目链接: [模板生成系统](http://118.190.20.162/view.page?gpid=T30)

TAG: `大模拟` `字符串`

思路:

`经典第三题大模拟题，这题相对于近几年的大模拟题友善了很多，题面也比较简短。但是题目中由于格式问题，输入数据看起来有些奇怪，理论上的输入数据如下：`

```cpp linenums="1"
11 2
<!DOCTYPE html>
<html>
<head>
<title>User {{ name }}</title>
</head>
<body>
<h1>David Beckham</h1>
<p>Email: <a href="mailto:{{ email }}">{{ email }}</a></p>
<p>Address: {{ address }}</p>
</body>
</html>
name "David Beckham"
email "david@beckham.com"
```

`只需要根据题意进行模拟即可，熟练使用string自带的一些函数例如substr(), find(), size()等可以简化代码。`

代码:

```cpp linenums="1"
#include<bits/stdc++.h>
using namespace std;

const int N=110;

string s[N]; // 使用字符串数组存数据，比二维字符数组来得简单一些
struct Node{ // 使用结构体存模板的对应关系，使用map<string,string>也可以
    string s1,s2;
}temp[N];

int main(){
    int n,m;
    cin>>n>>m;
    getchar(); // 后面的数据由于存在空格，需要使用getline读入数据，前面用的cin读入，会忽略空格和换行，因此这里需要使用getchar()读入上一行cin读入时忽略的换行符
    for(int i=1;i<=n;i++){
        getline(cin,s[i]); // getline()的一种用法，使用cin.getline()也可以
    }
    for(int i=1;i<=m;i++){
        cin>>temp[i].s1;
        getchar(); // 理由同上，读入cin忽略的空格
        getline(cin,temp[i].s2);
        temp[i].s2=temp[i].s2.substr(1,(int)temp[i].s2.size()-2); // 去除模板首尾的""
    }
    for(int i=1;i<=n;i++){
        int pos=0;
        while((pos=s[i].find("{{ ",pos))!=(int)string::npos){ // 循环寻找可替换的模板开始下标
            int endpos=s[i].find(" }}",pos); // 寻找模板结束下标
            string tt=s[i].substr(pos+3,endpos-(pos+3)); // 获取模板名
            bool ok=false; // 标记
            for(int j=1;j<=m;j++){ // 遍历每一个已知的模板，使用map的话可以不需要循环
                if(tt==temp[j].s1){ // 如果和当前模板匹配上
                    s[i]=s[i].substr(0,pos)+temp[j].s2+s[i].substr(endpos+3,(int)s[i].size()-(endpos+3)); // 替换
                    ok=true; // 打上标记
                    break; // 匹配上了所以直接退出循环即可
                }
            }
            if(!ok){ // 没有一个能匹配的话
                s[i]=s[i].substr(0,pos)+s[i].substr(endpos+3,(int)s[i].size()-(endpos+3));
                continue; // 直接continue，不需要将pos++，避免"{{ 模板1 }}{{ 模板2 }}"这种情况。但官网的数据没有这种情况，不写也能过，很离谱
            }
            pos++; // 将寻找的下标加一
        }
        cout<<s[i]<<"\n";
    }
    return 0;
}
```

---

## 第 4 题 高速公路(暂无)

题目链接: [高速公路](http://118.190.20.162/view.page?gpid=T29)

TAG: `暂无`

思路:

`暂无`

代码:

```cpp linenums="1"
暂无
```

## 第 5 题 最佳文章(暂无)

题目链接: [最佳文章](http://118.190.20.162/view.page?gpid=T28)

TAG: `暂无`

思路:

`暂无`

代码:

```cpp linenums="1"
暂无
```
