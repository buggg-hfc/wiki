---
comments: true
---

??? note "视频题解"
    [CSP 认证第 0 次视频题解](https://www.bilibili.com/video/BV1MW4y1b7vn/)

---

## 第 1 题 出现次数最多的数

题目链接: [出现次数最多的数](http://118.190.20.162/view.page?gpid=T5)

TAG: `桶` `哈希`

思路:

`数组模拟桶即可`

代码:

```cpp linenums="1"
#include<bits/stdc++.h>
using namespace std;

const int N=10010;

int a[N];

int main(){
    int n;
    cin>>n;
    for(int i=0;i<n;i++){
        int t;
        cin>>t;
        a[t]++;
    }
    int ans=1;
    for(int i=1;i<=10000;i++){
        if(a[i]>a[ans]){
            ans=i;
        }
    }
    cout<<ans;
    return 0;
}
```

---

## 第 2 题 ISBN 号码

题目链接: [ISBN 号码](http://118.190.20.162/view.page?gpid=T4)

TAG: `模拟` `字符串`

思路:

`直接按照题意模拟即可`

代码:

```cpp linenums="1"
#include<bits/stdc++.h>
using namespace std;

int main(){
    string s;
    cin>>s;
    int sum=0,n=(int)s.size(),cnt=1;
    for(int i=0;i<n-1;i++){
        if(s[i]=='-')continue;
        sum+=(s[i]-'0')*cnt++;
    }
    sum%=11;
    if(sum==s[n-1]-'0'||(sum==10&&s[n-1]=='X')){
        cout<<"Right";
    }else{
        cout<<s.substr(0,12);
        if(sum==10)cout<<'X';
        else cout<<sum;
    }
    return 0;
}
```

---

## 第 3 题 最大的矩形

题目链接: [最大的矩形](http://118.190.20.162/view.page?gpid=T3)

TAG: `暴力` `单调栈(为O(n)做法，此题不需要)`

思路:

`由于数据范围很小，直接暴力遍历每个矩形能组成的最大矩形即可`

代码:

```cpp linenums="1"
#include<bits/stdc++.h>
using namespace std;

const int N=1010;

int a[N];

int main(){
    int n;
    cin>>n;
    for(int i=0;i<n;i++)cin>>a[i];
    int ans=0;
    for(int i=0;i<n;i++){
        int cnt=1;
        for(int j=i-1;~j;j--){
            if(a[j]<a[i])break;
            cnt++;
        }
        for(int j=i+1;j<n;j++){
            if(a[j]<a[i])break;
            cnt++;
        }
        ans=max(ans,cnt*a[i]);
    }
    cout<<ans;
    return 0;
}
```

---

## 第 4 题 有趣的数

题目链接: [有趣的数](http://118.190.20.162/view.page?gpid=T2)

TAG: `组合数学` `组合数`

思路:

`简单的组合数学。代码中需要求组合数，由于数据范围很小，直接递推即可`

代码:

```cpp linenums="1"
#include<bits/stdc++.h>
using namespace std;

typedef long long ll;
const int N=1010,mod=1e9+7;

ll c[N][N];

int main(){
    int n;
    cin>>n;
    for(int i=0;i<=n;i++){
        for(int j=0;j<=i;j++){
            if(!j)c[i][j]=1;
            else c[i][j]=(c[i-1][j]+c[i-1][j-1])%mod;
        }
    }
    ll ans=0;
    for(int x=2;x<=n-2;x++){
        ans=(ans+c[n-1][x]*(x-1)*(n-x-1))%mod;
    }
    cout<<ans;
    return 0;
}
```

## 第 5 题 I’m stuck!

题目链接: [I’m stuck!](http://118.190.20.162/view.page?gpid=T1)

TAG: `DFS`

思路:

`DFS模板题，两次DFS分别求出起点和终点可以到达的点即可`

代码:

```cpp linenums="1"
#include<bits/stdc++.h>
using namespace std;

const int N=55;

int n,m;
char g[N][N];
int dx[4]={-1,0,1,0};
int dy[4]={0,1,0,-1};
bool st1[N][N],st2[N][N];

bool check(int x,int y,int k){
    char ch=g[x][y];
    if(ch=='+'||ch=='S'||ch=='T')return true;
    if(ch=='-'&&k%2==1)return true;
    if(ch=='|'&&k%2==0)return true;
    if(ch=='.'&&k==2)return true;
    return false;
}

void dfs1(int x,int y){
    st1[x][y]=true;
    for(int i=0;i<4;i++){
        int nx=x+dx[i],ny=y+dy[i];
        if(nx<0||nx>=n||ny<0||ny>=m||g[nx][ny]=='#'||st1[nx][ny])continue;
        if(check(x,y,i))dfs1(nx,ny);
    }
}

void dfs2(int x,int y){
    st2[x][y]=true;
    for(int i=0;i<4;i++){
        int nx=x+dx[i],ny=y+dy[i];
        if(nx<0||nx>=n||ny<0||ny>=m||g[nx][ny]=='#'||st2[nx][ny])continue;
        if(check(nx,ny,i^2))dfs2(nx,ny);
    }
}

int main(){
    cin>>n>>m;
    for(int i=0;i<n;i++)cin>>g[i];
    int tx,ty;
    for(int i=0;i<n;i++){
        for(int j=0;j<m;j++){
            if(g[i][j]=='S')dfs1(i,j);
            else if(g[i][j]=='T'){
                tx=i,ty=j;
                dfs2(i,j);
            }
        }
    }
    int ans=0;
    for(int i=0;i<n;i++){
        for(int j=0;j<m;j++){
            if(st1[i][j]&&!st2[i][j]){
                ans++;
            }
        }
    }
    if(!st1[tx][ty])cout<<"I'm stuck!";
    else cout<<ans;
    return 0;
}
```