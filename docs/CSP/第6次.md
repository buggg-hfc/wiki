---
comments: true
---

??? note "视频题解（暂无）"
    [暂无]()

---

## 第 1 题 数位之和

题目链接: [数位之和](http://118.190.20.162/view.page?gpid=T37)

TAG: `基础语法`

思路:

`从个位开始将每一位依次累加进答案即可`

代码:

```cpp linenums="1"
#include<bits/stdc++.h>
using namespace std;

int main(){
    int n,ans=0;
    cin>>n;
    while(n){ // 当n不为0则进行循环
        ans+=n%10; // 将末位数字累加进答案
        n/=10; // 去除末位数字
    }
    cout<<ans;
    return 0;
}
```

---

## 第 2 题 消除类游戏

题目链接: [消除类游戏](http://118.190.20.162/view.page?gpid=T36)

TAG: `模拟`

思路:

`遍历每一位，判断是否被消除即可，需要注意的是，被消除的不能之间消掉，要打上标记最后输出的时候消除，否则可能会影响后面的元素`

代码:

```cpp linenums="1"
#include<bits/stdc++.h>
using namespace std;

const int N=40;

int n,m;
int a[N][N],b[N][N]; // a用于存储原数组，b用于存储最终是否被消除

// 如果横或竖连续3个元素相同则被消除
void check(int x,int y){
    if(a[x][y-1]==a[x][y]&&a[x][y]==a[x][y+1]) // 横着
        b[x][y-1]=b[x][y]=b[x][y+1]=1;
    if(a[x-1][y]==a[x][y]&&a[x][y]==a[x+1][y]) // 竖着
        b[x-1][y]=b[x][y]=b[x+1][y]=1;
}

int main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            cin>>a[i][j]; // 读入数组
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            check(i,j); // 依次判断每个元素是否能够被消除
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            if(b[i][j])cout<<"0 "; // 如果被消除则输出0
            else cout<<a[i][j]<<" "; // 否则输出原始值
        }
        cout<<"\n"; // 记得换行
    }
    return 0;
}
```

---

## 第 3 题 画图

题目链接: [画图](http://118.190.20.162/view.page?gpid=T35)

TAG: `大模拟` `搜索` `DFS`

思路:

`本题最大的坑点在于横纵坐标是反过来的。其他的按要求模拟即可。填充操作可用DFS或者BFS实现，这里采用DFS（太菜了，之前用BFS写炸了），感兴趣可以试着用BFS写一写。`

代码:

```cpp linenums="1"
#include<bits/stdc++.h>
using namespace std;

const int N=110;

int m,n,q;
char a[N][N]; // 存图
int dx[]={0,1,0,-1}; // 方向数组
int dy[]={1,0,-1,0};

void dfs(int x,int y,char ch){
    a[x][y]=ch; // 填充这一点
    for(int i=0;i<4;i++){ // 遍历四个方向
        int nx=x+dx[i],ny=y+dy[i];
        // 下面的判断依次是：是否越界，是否已经填充过，是否碰到边界
        if(nx<0||nx>=n||ny<0||ny>=m||a[nx][ny]==ch||a[nx][ny]=='|'||a[nx][ny]=='-'||a[nx][ny]=='+')continue;
        dfs(nx,ny,ch); // 没有的话继续搜索
    }
}

// 本题需要注意的点是横纵坐标是反过来的
int main(){
    memset(a,'.',sizeof a); // 将a数组中的元素全部初始化为'.'
    cin>>m>>n>>q;
    while(q--){ // 读入q次操作
        int op;
        cin>>op;
        if(op){ // 填充操作
            int x,y;
            char ch;
            cin>>x>>y>>ch;
            dfs(y,x,ch); // 使用dfs进行填充
        }else{ // 画线操作
            int x1,y1,x2,y2;
            cin>>x1>>y1>>x2>>y2;
            if(x1==x2){ // 竖线
                if(y1>y2)swap(y1,y2); // 确保下一行的for循环是从小到大遍历
                for(int i=y1;i<=y2;i++){
                    if(a[i][x1]=='+')continue;
                    if(a[i][x1]=='-')a[i][x1]='+';
                    else a[i][x1]='|';
                }
            }else{ // 横线
                if(x1>x2)swap(x1,x2);
                for(int i=x1;i<=x2;i++){
                    if(a[y1][i]=='+')continue;
                    if(a[y1][i]=='|')a[y1][i]='+';
                    else a[y1][i]='-';
                }
            }
        }
    }
    for(int i=n-1;i>=0;i--){
        for(int j=0;j<m;j++){
            cout<<a[i][j];
        }
        cout<<"\n";
    }
    return 0;
}
```

---

## 第 4 题 送货(暂无)

题目链接: [送货](http://118.190.20.162/view.page?gpid=T34)

TAG: `暂无`

思路:

`暂无`

代码:

```cpp linenums="1"
暂无
```

## 第 5 题 矩阵(暂无)

题目链接: [矩阵](http://118.190.20.162/view.page?gpid=T33)

TAG: `暂无`

思路:

`暂无`

代码:

```cpp linenums="1"
暂无
```
