# 字符串进阶

**计算机学院 21级 何丰辰**

---

## 1. Manacher

### 1.1 基础知识

- 回文串：若一个字符串从左向右读和从右向左读是一样的，则称为回文串
- 字符串长度：字符串中的字符数称为字符串的长度
- 回文串按长度的奇偶分为奇数长度的回文串和偶数长度的回文串
- 子串：一个字符串中连续的一段字符串
- 回文子串：是一个字符串的子串且是回文串

### 1.2 最长回文子串问题

#### 1.2.1 描述

求给定字符串中最长的回文子串

#### 1.2.2 暴力做法

枚举所有子串，分别检查是否是回文串

复杂度分析：

- 枚举子串：$O(n^2)$
- 检查是否是回文串：$O(n)$

总时间复杂度：$O(n^3)$

#### 1.2.3 优化

容易发现，若一个字符串 $s$ 不是回文串，那么在 $s$ 两边加上同样长度的字符得到的字符串也不是回文串

因此考虑枚举回文串的中心位置，然后向两边扩展到最远位置

复杂度分析：

- 枚举中心位置：$O(n)$
- 向两边扩展：$O(n)$

总时间复杂度：$O(n^2)$

???+ note "注意"
    枚举中心位置的时候要按照子串长度的奇偶分类讨论

#### 1.2.4 其他做法

- 二分+哈希：$O(nlogn)$
- Manacher：$O(n)$

### 1.3 Manacher

#### 1.3.1 描述

Manacher，俗称“马拉车”，可以在线性时间复杂度内求出从字符串中任意位置出发，向两边最远能扩展出的回文子串的长度

#### 1.3.2 小技巧

在正式介绍Manacher算法前，先学习一个小技巧：

对于字符串 $s$，用一个 $s$ 中不存在的字符（例如 $'\$'、'\#'$ 等）把 $s$ 中的字符隔开（开头和结尾也要加）

例：

- $aba$ 变为 $\$a\$b\$a\$$
- $cc$ 变为 $\$c\$c\$$

结论：已知新字符串的奇数长度的最长回文子串长度为 $len$，原字符串最长回文子串长度为 $\frac{len}{2}$

???+ note "简单证明"
    设原串为 $s$，长度为 $n$，新串为 $t$，长度为 $m$，新串中奇数长度的最长回文子串长度为 $len$
    已知 $$t[i]=\begin{cases}插入的字符& \text{i为奇数}\\原串中的字符& \text{i为偶数}\end{cases}$$
    又因为 $\text{插入的字符}\neq\text{原串中的字符}$
    所以相邻的字符 $t[i] \neq t[i+1],\ (1 \leq i \leq m-1)$，即不存在偶数长度的回文子串
    因此只需考虑奇数长度的回文子串
    而显然无论奇数长度的回文子串的中心是插入的字符或者是原串中的字符，其左右两端点的字符都是插入的字符
    此时有 $\frac{len}{2}$ 个原串中的字符，有 $\frac{len}{2}+1$ 个插入的字符，故原串最长回文子串长度为 $\frac{len}{2}$
    证明新串最长回文子串恰好是原串最长回文子串加上插入的字符这一过程省略。

#### 1.3.3 算法步骤

记通过上述小技巧处理后的新字符串为 $s$，要求出从任意位置 $i$ 出发，向两边最远扩展的回文子串长度

我们把向一边能够扩展的字符数记为从 $i$ 开始的 **最大回文半径**，记作 $p[i]$，需要注意的是 $p[i]$ 包括 $i$ 自身

我们从左向右依次计算 $p[i]$

假设我们已经求出了 $p[1],p[2],\cdots,p[i-1]$，那么我们可以维护使得回文半径最大的 $M$ 和以 $M$ 为中心的区间 $[L,R]$

显然 $$\begin{cases}L=M-p[M]+1& (M<i)\\R=M+p[M]-1& (M<i)\end{cases}$$

接着进行分类讨论：

- $i \leq R$：找到 $i$ 关于 $M$ 的对称点 $k$（此时 $i-M=M-k$，即 $k=2M-i$）
    - $p[k]$ 对应的回文区间 $[k-p[k]+1,k+p[k]-1]$ 不包含左端点 $L$
        - 即 $L<k-p[k]+1$
        - 又 $L=2M-R$ 且 $k=2M-i$
        - 则 $2M-R<2M-i-p[k]+1$，即 $p[k]<R-i+1$
        - 此时 $[k-p[k]+1,k+p[k]-1]$ 包含于 $[L,R]$
        - 故 $p[i]=p[k]$，且 $s[i-p[i]] \neq s[i+p[i]]$
        - 因此无需暴力向两边扩展
    - $p[k]$ 对应的回文区间 $[k-p[k]+1,k+p[k]-1]$ 包含左端点 $L$
        - 即 $L \ge k-p[k]+1$
        - 又 $L=2M-R$ 且 $k=2M-i$
        - 则 $2M-R \ge 2M-i-p[k]+1$，即 $R-i+1 \leq p[k]$
        - 此时 $[L,2k-L]$ 是回文串
        - 又 $[L,R]$ 是回文串
        - 则 $[2i-R,R]$ 也是回文串
        - 故 $p[i]=R-i+1$
        - 然后再暴力向两边扩展即可
- $i>R$
    - $p[i]=1$
    - 直接暴力向两边扩展即可

每轮循环后更新 $M、L、R$

最后找到所有 $p[i]$ 中的最大值 $x$，易得此时 $x=\frac{len}{2}+1$，因此最终答案为 $x-1$

复杂度分析：暴力扩展的过程中 $R$ 的值也在同步增加，$R$ 最多只会增加 $O(n)$ 次，因此总时间复杂度为 $O(n)$

#### 1.3.4 代码模板

```cpp
int manacher(string s){
    int n=(int)s.size();
    vector<int> p(2*n+2);
    vector<char> t(2*n+3);
    int m=0;
    t[++m]='$';
    for(int i=0;i<n;i++){
        t[++m]=s[i];
        t[++m]='$';
    }
    int M=0,R=0;
    for(int i=1;i<=m;i++){
        if(i>R)p[i]=1;
        else p[i]=min(p[2*M-i],R-i+1);
        while(i-p[i]>=1&&i+p[i]<=m&&t[i-p[i]]==t[i+p[i]])++p[i];
        if(i+p[i]-1>R)M=i,R=i+p[i]-1;
    }
    int ans=0;
    for(int i=1;i<=m;i++)ans=max(ans,p[i]);
    return ans-1;
}
```

#### 1.3.5 例题

1. [回文子串的最大长度](https://www.acwing.com/problem/content/141/)

    题目大意：求字符串的最长回文子串的长度
    
    分析：模板题
    
    代码：

    ```cpp
    #include<bits/stdc++.h>
    using namespace std;
    
    int manacher(string s){
        int n=(int)s.size();
        vector<int> p(2*n+2);
        vector<char> t(2*n+3);
        int m=0;
        t[++m]='$';
        for(int i=0;i<n;i++){
            t[++m]=s[i];
            t[++m]='$';
        }
        int M=0,R=0;
        for(int i=1;i<=m;i++){
            if(i>R)p[i]=1;
            else p[i]=min(p[2*M-i],R-i+1);
            while(i-p[i]>=1&&i+p[i]<=m&&t[i-p[i]]==t[i+p[i]])++p[i];
            if(i+p[i]-1>R)M=i,R=i+p[i]-1;
        }
        int ans=0;
        for(int i=1;i<=m;i++)ans=max(ans,p[i]);
        return ans-1;
    }
    
    int main(){
        string s;
        int cnt=0;
        while(cin>>s){
            if(s!="END")cout<<"Case "<<++cnt<<": "<<manacher(s)<<"\n";
            else break;
        }
        return 0;
    }
    ```

2. [Palisection](https://codeforces.com/contest/17/problem/E)

    题目大意：给定一个由小写字母组成的字符串 $s$，求出 $s$ 中有多少对有公共部分的回文子串。$1\leq|s|\leq2*{10}^{6}$

    分析：

    $\text{有公共部分的回文子串对}=\text{回文字串对}-\text{没有公共部分的回文子串对}$

    $\text{回文子串对}=\frac{\text{回文子串}*(\text{回文子串-1})}{2}$
    
    回文子串可通过 $p[i]$ 求出
    
    没有公共部分的回文子串对与两部分相关：
    
    1. 以 $i$ 结尾的回文子串数
    2. 以大于 $i$ 开头的回文子串数
    
    可以通过前缀和与后缀和求出上面两个值
    
    每一种操作都是 $O(n)$，且互不相关，因此总时间复杂度为 $O(n)$
    
    代码：
    
    ```cpp
    #include<bits/stdc++.h>
    using namespace std;
    
    using ll=long long;
    const int mod=51123987;
    
    int manacher(string s){
        int n=(int)s.size();
        vector<int> p(2*n+2),f(n+2),v(n+2);
        vector<char> t(2*n+3);
        int m=0;
        t[++m]='$';
        for(int i=0;i<n;i++){
            t[++m]=s[i];
            t[++m]='$';
        }
        int M=0,R=0;
        for(int i=1;i<=m;i++){
            if(i>R)p[i]=1;
            else p[i]=min(p[2*M-i],R-i+1);
            while(i-p[i]>=1&&i+p[i]<=m&&t[i-p[i]]==t[i+p[i]])++p[i];
            if(i+p[i]-1>R)M=i,R=i+p[i]-1;
        }
        ll x=0;
        for(int i=1;i<=m;i++){
            int l=(i-p[i]+2)/2,r=i/2;
            ++v[l];--v[r+1];
            l=(i+1)/2,r=(i+p[i]-2)/2;
            ++f[l];--f[r+1];
            x+=r-l+1;
        }
        for(int i=1;i<=n+1;i++)
            v[i]+=v[i-1];
        for(int i=1;i<=n;i++)
            f[i]+=f[i-1];
        for(int i=n-1;i;i--)
            v[i]+=v[i+1],v[i]%=mod;
        ll ans=0;
        if(x&1)ans=x%mod*((x-1)/2%mod)%mod;
        else ans=x/2%mod*((x-1)%mod)%mod;
        for(int i=1;i<=n;i++){
            ans-=(ll)f[i]*v[i+1]%mod;
            if(ans<0)ans+=mod;
        }
        return ans;
    }
    
    int main(){
        int n;
        cin>>n;
        string s;
        cin>>s;
        cout<<manacher(s);
        return 0;
    }
    ```


## 2. 最小表示法