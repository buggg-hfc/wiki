---
comments: true
---

# 线性表

## 线性表的概念

- `线性表`: 是由 $n\ (n\ge0)$ 个具有 **相同类型** 的 **数据元素** 组成的有限序列（即线性表的元素之间是有序的）。其中数据元素的个数 $n$ 定义为线性表的长度
- 在稍微复杂的线性表中，一个数据元素可以由若干 **数据项** 组成，在这种情况下，通常把数据元素称为 **记录**

## 线性表的顺序存储结构

### 定义

- `线性表的顺序存储结构`: 用一段 **地址连续** 的存储单元依次存储线性表的数据元素，简称为 **顺序表**

???+ note "数组长度与线性表长度的区别"
    数组的长度是存放线性表的储存空间的长度，存储分配后这个量一般是不变的（通过可变长数组类型也可以改变，但是会带来一定的性能损耗）
    线性表长度是线性表中数据元素的个数，随着线性表插入和删除操作的进行，这个量是变化的
    在任意时刻，线性表长度应该小于等于数组长度

### 地址计算方式

存储器中的每个存储单元都有自己的编号，这个编号称为地址

假设每个数据元素占用 $c$ 个存储单元，那么线性表中第 $i+1$ 个数据元素的存储位置满足下列关系（$LOC$ 表示获得存储位置的函数）：

$$LOC(a_{i+1})=LOC(a_{i})+c$$

所以对于第 $i$ 个数据元素 $a_{i}$ 的存储位置可以由 $a_{1}$ 推算得出：

$$LOC(a_{i})=LOC(a_{1})+(i-1)*c$$

通过这个公式可以用 $O(1)$ 的时间复杂度算出线性表中任意位置的地址，那么也就可以对每个位置存入或取出数据。

我们把具有这一特点的存储结构称为 **随机存取结构**，顺序表也是一种随机存取结构

### 代码实现

在高级语言中，一维数组和具有和循序表相同的三个特性：

1. 一维数组的存储对象也是一组 **相同类型** 的数据
2. 一维数组也是用一组 **地址连续** 的存储单元存放数据
3. 一组数组中的数据元素也可以通过数组下标 **随机存取**


因此，可以用一维数组来描述顺序表，本文使用 `vector` 可变长数组来定义一维数组，这样可以将重点放在数据结构的原理上而不是语法上，具体的定义和操作代码如下：

```cpp linenums=1
template<typename T>
struct Array{
  // 初始化顺序表
  int length=0;
  vector<T> a;
  // 销毁顺序表
  void delete_all(){
    a.resize(0);
  }
  // 顺序表插入数据元素
  void insert(int k,T e){
    a.push_back(0);
    length++;
    for(int i=length-1;i>=k+1;i—-){
      a[i]=a[i-1];
    }
    a[k]=e;
  }
  // 顺序表删除数据元素
  void delete(int k){
    for(int i=k;i<length-1;i++){
      a[i]=a[i+1];
    }
    a.pop_back();
    length—-;
  }
  // 顺序表范围数据元素的位置i
  int get_index(T e){
    for(int i=0;i<length;i++){
      if(a[i]==e){
        return i;
      }
    }
    return -1;
  }
  // 顺序表返回第i个位置的数据元素的值
  int get_element(int i){
    if(i<0||i>=length)return -1;
    return a[i];
  }
}
```

## 线性表的链式存储结构

### 定义

在顺序结构中，每个数据元素只需要存储数据元素信息就可以了，而在链式结构中，除了要存储数据元素信息，还要存储它的后继元素的存储地址

- `数据域`: 存储数据元素信息的域
- `指针域`: 存储直接后继位置的域，指针域中存储的信息称作 **指针** 或 **链**
- `结点`: 数据域和指针域两部分信息组成的数据元素的存储映像

在链式存储结构中，逻辑上相邻的两个数据元素其存储的物理位置不一定相邻，这种存储结构称为 **非顺序映像** 或 **链式映像**

### 单链表

### 静态链表

### 循环链表

### 双向链表

## 总结

我们可以用警匪片中的组织关系来理解顺序表的两种存储结构的区别：

在许多警匪片中，警方的组织纪律严明，每个支队都分配有一个编号（下标）和值守的辖区（地址），为了便于管理，常常让编号相邻的支队值守的辖区也相邻（逻辑相邻，物理地址也相邻）。如果要查询某个支队所值守的辖区，只需要知道编号即可直接算出（通过下标直接算出地址）；如果要某个支队要去执行任务，需要删除相关信息，那么它所值守的辖区就无人值守，因此在它之后的支队所所值守的辖区均需往前挪一格（删除某个结点影响到在它之后的所有结点。需要注意的是：最后一个支队值守的辖区就无人值守了，逻辑上我们可以认为该辖区已经无需值守，但实际上仍然存在，即逻辑上删除，物理上存在）。那么这其实就是顺序表结构。

在黑帮势力中，每名黑帮分子都有一个编号（下标）和一个藏身处（地址），为了避免通过编号查出藏身处（通过下标索引查询地址），黑帮分子的藏身处与他们的编号不一定有关联（逻辑相邻，物理地址不一定相邻）。而为了降低被同伙出卖的风险，黑帮内会保持 **单向单线联络**，即每个人最多只有一个上线，一个下线，只有上线知道下线的藏身处（前驱结点记录直接后继结点的地址），那么只有上线可以联络下线。如果要警方要找到某一名黑帮分子的藏身处，就需要抓到黑帮头头，问出他的下线藏身处，以此循环，知道问出要找的那名黑帮分子为止（查询某一结点信息，需要从头结点开始按顺序往后依次查询）；如果黑帮中新加入一名成员，那么只需要先给他指派一名下线，再指派一名上线即可（单链表的插入操作，可以复习一下课上内容）。那么这其实就是单链表结构。

其他更为复杂的链表也可以用类似的类比来帮助理解，在此暂不进行展开叙述。

| 存储结构   | 查询  | 修改  |
|:------------:|:------:|:------:|
| 顺序存储结构 | $O(1)$ | $O(n)$ |
| 链式存储结构 | $O(n)$ | $O(1)$ |